/***********************************
Copyright 2023 Ravishankar Mathur

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
***********************************/

#include "ofcontrols.hpp"
#include "renderthread.hpp"
#include "ofwindow.hpp"
#include "ui_sphereoptionsform.h" // Autogenerated by Qt

#include <OpenFrames/QWidgetPanel.hpp>
#include <OpenFrames/WindowProxy.hpp>
#include <OpenFrames/Sphere.hpp>
#include <OpenFrames/OpenVRDevice.hpp>

#include <QApplication>
#include <QWidget>
#include <QVBoxLayout>
#include <QTextEdit>
#include <QPushButton>
#include <QCheckBox>
#include <QListWidget>
#include <QSlider>
#include <QtUiTools>

/// The period of event checking in the main loop (milliseconds)
const double OFControls::MAIN_LOOP_PERIOD = 10;

/// Prose for the text edit control
const char *OFControls::LOREM_IPSUM_DOLOR =
  "This is an example of Qt widgets in an OSG texture. The widgets control the sphere sitting above.";

/// Colors for the sphere demo
const std::map<std::string, osg::Vec4> OFControls::COLORS =
  {
    { "Red", { 1.0, 0.0, 0.0, 1.0 } },
    { "Green", { 0.0, 0.5, 0.0, 1.0 } },
    { "Blue", { 0.0, 0.0, 1.0, 1.0 } },
    { "Purple", { 1.0, 0.0, 1.0, 1.0 } },
    { "Yellow", { 1.0, 1.0, 0.0, 1.0 } },
    { "Cyan", { 0.0, 1.0, 1.0, 1.0 } },
    { "Orange", { 1.0, 0.5, 0.0, 1.0 } },
    { "Navy", { 0.0, 0.0, 0.5, 1.0 } },
    { "Gray", { 0.5, 0.5, 0.5, 1.0 } },
};

/// Default color for the sphere
const char *OFControls::DEFAULT_SPHERE_COLOR = COLORS.begin()->first.c_str();

// Default panel dimensions
const double OFControls::panelWidth = 1.5;
const double OFControls::panelHeight = 1.2;
const double OFControls::panelZPos = -1.0;


int main(int argc, char **argv)
{
  // Parse user inputs
  osg::ArgumentParser arguments(&argc, argv);

  // Use VR mode
  bool useVR = arguments.read("--vr");

  // Qt requires that we construct the global QApplication before creating any widgets.
  QApplication *app;
  app = new QApplication(argc, argv);

  // Configure the default appearance for our VR world
  QFont font = app->font();
  font.setPixelSize(20);
  app->setFont(font);
  QSurfaceFormat fmt;
  fmt.setDepthBufferSize(24); // 24-bit depth buffer
  fmt.setSamples(4);          // 4x MSAA (multisample antialiasing)
  QSurfaceFormat::setDefaultFormat(fmt);

  // Start main app
  static OFControls controls(useVR);
  app->exec();
}

OFControls::OFControls(bool useVR)
{
  osg::Vec4 bgColor = { 0.8f, 0.8f, 0.8f, 0.9f };

  // Instantiate and configure OpenFrames objects
  int x = 100, y = 100;
  unsigned int width = 640, height = 480;
  unsigned int nrow = 1, ncol = 1;
  if (useVR)
  {
    width = 1080 / 2;
    height = 1200 / 2;
  }
  _renderer = new RenderThread(nullptr, width, height, nrow, ncol, useVR);

  // Set VR scale
  if (useVR) _renderer->winproxy()->setWorldUnitsPerMeter(1.0);

  // Set default VR laser properties
  // These are used if the laser is not pointing at anything
  if (useVR)
  {
    const OpenFrames::OpenVRDevice* ovrDevice = _renderer->winproxy()->getOpenVRDevice();
    for (unsigned int i = 0; i < ovrDevice->getNumDeviceModels(); ++i)
    {
      if (ovrDevice->getDeviceModel(i)->_laser)
      {
        ovrDevice->getDeviceModel(i)->_laser->setDefaultColor(osg::Vec4(0.8, 0.8, 0.8, 1));
        ovrDevice->getDeviceModel(i)->_laser->setDefaultWidth(2.0);
        ovrDevice->getDeviceModel(i)->_laser->setDefaultLength(10.0);
      }
    }
  }

  _root = new OpenFrames::ReferenceFrame("root");
  _root->showNameLabel(false);
  _root->showAxes(0U);
  _root->showAxesLabels(0U);

  // The sphere that will be manipulated by Qt controls
  _sphere = new OpenFrames::Sphere("sphere");
  _sphere->setRadius(1.0);
  _sphereOrigin.set(-1.55, 0.0, panelZPos + panelHeight + _sphere->getRadius());
  _sphere->setPosition(_sphereOrigin);
  _sphere->setColor(COLORS.at(DEFAULT_SPHERE_COLOR));
  _sphere->showNameLabel(false);
  _sphere->showAxes(0U);
  _sphere->showAxesLabels(0U);
  _root->addChild(_sphere);

  // Panel that will hold a text editor
  OpenFrames::QWidgetPanel *editorPanel = new OpenFrames::QWidgetPanel("EditorPanel");
  editorPanel->setColor(bgColor);
  editorPanel->setSize(panelWidth, panelHeight);
  editorPanel->setAttitude(osg::Quat(osg::PI_2, osg::Vec3d(1.0, 0.0, 0.0))); // Make panel face user (panel +y -> world +z)
  editorPanel->setPosition(0.0, 0.0, panelZPos);
  editorPanel->showNameLabel(false);
  editorPanel->showAxes(0U);
  editorPanel->showAxesLabels(0U);
  _root->addChild(editorPanel);

  // Panel that will hold checkboxes with sphere options
  OpenFrames::QWidgetPanel *sphereOptionsPanel = new OpenFrames::QWidgetPanel("OptionsPanel");
  sphereOptionsPanel->setColor(bgColor);
  sphereOptionsPanel->setSize(panelWidth, panelHeight);
  sphereOptionsPanel->setPosition(panelWidth + 0.1, 0.0, panelZPos);
  sphereOptionsPanel->setAttitude(osg::Quat(osg::PI_2, osg::Vec3d(1.0, 0.0, 0.0))); // Make panel face user (panel +y -> world +z)
  sphereOptionsPanel->showNameLabel(false);
  sphereOptionsPanel->showAxes(0U);
  sphereOptionsPanel->showAxesLabels(0U);
  _root->addChild(sphereOptionsPanel);

  // Panel that will hold a list of colors
  OpenFrames::QWidgetPanel *colorPanel = new OpenFrames::QWidgetPanel("ColorPanel");
  colorPanel->setColor(bgColor);
  colorPanel->setSize(panelWidth, panelHeight);
  colorPanel->setPosition(-(panelWidth + 0.1), 0.0, panelZPos);
  colorPanel->setAttitude(osg::Quat(osg::PI_2, osg::Vec3d(1.0, 0.0, 0.0))); // Make panel face user (panel +y -> world +z)
  colorPanel->showNameLabel(false);
  colorPanel->showAxes(0U);
  colorPanel->showAxesLabels(0U);
  _root->addChild(colorPanel);

  // Hidden panel that will hold sliders to move the sphere
  _hiddenPanel = new OpenFrames::QWidgetPanel("PositionPanel");
  _hiddenPanel->setColor(bgColor);
  _hiddenPanel->showNameLabel(false);
  _hiddenPanel->showAxes(0U);
  _hiddenPanel->showAxesLabels(0U);
  setHiddenPanel(false);
  
  bool foundVRController = false;
  if (useVR) // Try to place hidden panel on VR controller
  {
    const OpenFrames::OpenVRDevice *ovrDevice = _renderer->winproxy()->getOpenVRDevice();
    for (unsigned int i = 0; i < ovrDevice->getNumDeviceModels(); ++i)
    {
      // Find controller
      const OpenFrames::OpenVRDevice::DeviceModel* device = ovrDevice->getDeviceModel(i);
      if (device->_class == OpenFrames::OpenVRDevice::CONTROLLER)
      {
        double panelScale = 0.1; // Make hidden panel smaller to fit above controller
        _hiddenPanel->setSize(panelWidth*panelScale, panelHeight*panelScale);
        _hiddenPanel->setPosition(-panelWidth/2.0*panelScale, 0.05, 0.0);
        _hiddenPanel->setAttitude(osg::Quat(osg::PI_2, osg::Vec3d(-1.0, 0.0, 0.0))); // Make panel face user (panel +y -> controller -z)
        device->_modelTransform->addChild(_hiddenPanel->getGroup());
        foundVRController = true;
        break;
      }
    }
  }
  
  if(!foundVRController) // Otherwise just place in scene
  {
    _hiddenPanel->setSize(panelWidth, panelHeight);
    _hiddenPanel->setPosition(panelWidth + 0.1, 0.0, panelZPos + panelHeight + 0.1);
    _hiddenPanel->setAttitude(osg::Quat(osg::PI_2, osg::Vec3d(1.0, 0.0, 0.0))); // Make panel face user (panel +y -> world +z)
    _root->addChild(_hiddenPanel);
  }

  // Create the text editor widget
  QWidget *editorParentWidget = new QWidget;
  editorParentWidget->setLayout(new QVBoxLayout);
  QString text(LOREM_IPSUM_DOLOR);
  QTextEdit *textEdit = new QTextEdit(text);
  textEdit->setReadOnly(false);
  QPalette palette = textEdit->palette();
  palette.setColor(QPalette::Highlight, Qt::darkBlue);
  palette.setColor(QPalette::HighlightedText, Qt::white);
  textEdit->setPalette(palette);
  editorParentWidget->layout()->addWidget(textEdit);
  _toggleButton = new QPushButton("Hide Sphere");
  editorParentWidget->layout()->addWidget(_toggleButton);
  // If Qt's autocomputed preferred size is poor, then you can override it
  //editorParentWidget->setMinimumSize(QSize(400, 300));
  editorPanel->setWidget(editorParentWidget);
  //editorPanel->setIgnoreWidget(editorParentWidget, true); // Causes GUI calls on render thread
  if (useVR)
  {
    OpenFrames::OpenVRImageHandler* ih = new OpenFrames::OpenVRImageHandler(_renderer->winproxy()->getOpenVRDevice(), editorPanel->getImage());
    ih->setSelectedColor(osg::Vec4(0.0, 0.5, 0.9, 1.0));
    ih->setSelectedWidth(4.0);
    editorPanel->setImageHandler(ih);
  }

  // Create the sphere options widget, built at compile time from the ui file
  QWidget *sphereOptionsWidget = new QWidget;
  Ui_SphereOptions ui;
  ui.setupUi(sphereOptionsWidget);
  _showCheckBox = sphereOptionsWidget->findChild<QCheckBox*>("showSphereUI");
  _showCheckBox->setChecked(true);
  QCheckBox *moveSphereCheckBox = sphereOptionsWidget->findChild<QCheckBox*>("moveSphereUI");
  sphereOptionsPanel->setWidget(sphereOptionsWidget);
  //sphereOptionsPanel->setIgnoreWidget(sphereOptionsWidget, true); // Causes GUI calls on render thread
  if (useVR)
  {
    OpenFrames::OpenVRImageHandler* ih = new OpenFrames::OpenVRImageHandler(_renderer->winproxy()->getOpenVRDevice(), sphereOptionsPanel->getImage());
    ih->setSelectedColor(osg::Vec4(0.0, 0.5, 0.9, 1.0));
    ih->setSelectedWidth(4.0);
    sphereOptionsPanel->setImageHandler(ih);
  }

  // Create the example list view
  _list = new QListWidget();
  _list->setIconSize(QSize(30, 30));
  for (auto color = COLORS.begin(); color != COLORS.end(); color++)
  {
    QListWidgetItem *item = new QListWidgetItem(color->first.c_str());
    const osg::Vec4 &osgColor = color->second;
    QColor qColor(round(osgColor[0]*255.0), round(osgColor[1]*255.0), round(osgColor[2]*255.0));
    QFont font = item->font();
    font.setPixelSize(30);
    item->setFont(font);
    QPixmap pixmap(QSize(30, 30));
    pixmap.fill(qColor);
    item->setIcon(QIcon(pixmap));
    _list->addItem(item);
  }
  QList<QListWidgetItem *> matchingItems = _list->findItems(DEFAULT_SPHERE_COLOR, Qt::MatchExactly);
  if (matchingItems.size() > 0)
  {
    _list->setCurrentItem(matchingItems[0]);
  }
  colorPanel->setWidget(_list);
  if (useVR)
  {
    OpenFrames::OpenVRImageHandler* ih = new OpenFrames::OpenVRImageHandler(_renderer->winproxy()->getOpenVRDevice(), colorPanel->getImage());
    ih->setSelectedColor(osg::Vec4(0.0, 0.5, 0.9, 1.0));
    ih->setSelectedWidth(4.0);
    colorPanel->setImageHandler(ih);
  }

  // Create the example slider controls widget, loaded from ui file in resources at runtime
  QFile file(":/forms/movesphereform.ui");
  file.open(QIODevice::ReadOnly);
  QUiLoader loader;
  QWidget *moveSphereWidget = loader.load(&file, nullptr);
  QSlider *xSlider = moveSphereWidget->findChild<QSlider*>("xSliderUI");
  QSlider *ySlider = moveSphereWidget->findChild<QSlider*>("ySliderUI");
  QSlider *zSlider = moveSphereWidget->findChild<QSlider*>("zSliderUI");
  _hiddenPanel->setWidget(moveSphereWidget);
  //_hiddenPanel->setIgnoreWidget(moveSphereWidget, true); // Causes GUI calls on render thread
  if (useVR)
  {
    OpenFrames::OpenVRImageHandler* ih = new OpenFrames::OpenVRImageHandler(_renderer->winproxy()->getOpenVRDevice(), _hiddenPanel->getImage());
    ih->setSelectedColor(osg::Vec4(0.0, 0.5, 0.9, 1.0));
    ih->setSelectedWidth(4.0);
    _hiddenPanel->setImageHandler(ih);
  }

  // Connect QObject signals to our slots
  QObject::connect(moveSphereCheckBox, &QCheckBox::clicked, this, &OFControls::setHiddenPanel);
  QObject::connect(_toggleButton, &QPushButton::clicked, this, &OFControls::toggleSphere);
  QObject::connect(_showCheckBox, &QCheckBox::clicked, this, &OFControls::setSphere);
  QObject::connect(_list, &QListWidget::itemActivated, this, &OFControls::setColor);
  QObject::connect(_list, &QListWidget::itemClicked, this, &OFControls::setColor);
  QObject::connect(xSlider, &QSlider::valueChanged, this, &OFControls::setXLocation);
  QObject::connect(ySlider, &QSlider::valueChanged, this, &OFControls::setYLocation);
  QObject::connect(zSlider, &QSlider::valueChanged, this, &OFControls::setZLocation);

  // Setup WindowProxy frame and views
  OpenFrames::FrameManager *frameManager = new OpenFrames::FrameManager();
  frameManager->setFrame(_root);
  _renderer->winproxy()->setScene(frameManager, 0U, 0U);
  _renderer->winproxy()->getGridPosition(0U, 0U)->addView(new OpenFrames::View(_root, _root, OpenFrames::View::ABSOLUTE_FRAME));
  OpenFrames::FollowingTrackball *trackball = _renderer->winproxy()->getGridPosition(0U, 0U)->getCurrentView()->getTrackball();
  trackball->setDistance(6.0);

  _window = new OFWindow(*_renderer, nullptr);
  _window->setTitle("Qt Controls Example");
  _window->show();
  _window->resize(width, height);
}

OFControls::~OFControls()
{
  delete _window;
  delete _renderer;
}

void OFControls::toggleSphere()
{
  setSphere(!_sphere->getContentsShown());
}

void OFControls::setSphere(bool checked)
{
  _showCheckBox->setChecked(checked);
  _sphere->showContents(checked);

  if (checked)
    _toggleButton->setText("Hide Sphere");
  else
    _toggleButton->setText("Show Sphere");
}

void OFControls::setColor(QListWidgetItem *item)
{
  _sphere->setColor(COLORS.at(item->text().toStdString()));
}

void OFControls::setHiddenPanel(bool checked)
{
  _hiddenPanel->showContents(checked);
}

void OFControls::setXLocation(int position)
{
  osg::Vec3d spherePosition;
  _sphere->getPosition(spherePosition);
  spherePosition[0] = _sphereOrigin[0] + static_cast<double>(position) * 0.1;
  _sphere->setPosition(spherePosition);
}

void OFControls::setYLocation(int position)
{
  osg::Vec3d spherePosition;
  _sphere->getPosition(spherePosition);
  spherePosition[1] = _sphereOrigin[1] + static_cast<double>(position) * 0.1;
  _sphere->setPosition(spherePosition);
}

void OFControls::setZLocation(int position)
{
  osg::Vec3d spherePosition;
  _sphere->getPosition(spherePosition);
  spherePosition[2] = _sphereOrigin[2] + (static_cast<double>(position) * 0.1);
  _sphere->setPosition(spherePosition);
}
